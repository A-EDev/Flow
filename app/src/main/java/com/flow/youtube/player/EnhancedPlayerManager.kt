package com.flow.youtube.player

import android.content.Context
import android.util.Log
import androidx.media3.common.AudioAttributes
import androidx.media3.common.C
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.common.util.UnstableApi
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.exoplayer.source.MergingMediaSource
import androidx.media3.exoplayer.source.ProgressiveMediaSource
import androidx.media3.exoplayer.trackselection.DefaultTrackSelector
import androidx.media3.datasource.DefaultHttpDataSource
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import org.schabi.newpipe.extractor.stream.AudioStream
import org.schabi.newpipe.extractor.stream.SubtitlesStream
import org.schabi.newpipe.extractor.stream.VideoStream

@UnstableApi
object EnhancedPlayerManager {
    private var player: ExoPlayer? = null
    private var trackSelector: DefaultTrackSelector? = null
    private val _playerState = MutableStateFlow(EnhancedPlayerState())
    val playerState: StateFlow<EnhancedPlayerState> = _playerState.asStateFlow()
    
    private var currentVideoId: String? = null
    private var availableVideoStreams: List<VideoStream> = emptyList()
    private var availableAudioStreams: List<AudioStream> = emptyList()
    private var availableSubtitles: List<SubtitlesStream> = emptyList()

    fun initialize(context: Context) {
        if (player == null) {
            trackSelector = DefaultTrackSelector(context)
            
            player = ExoPlayer.Builder(context)
                .setTrackSelector(trackSelector!!)
                .setAudioAttributes(
                    AudioAttributes.Builder()
                        .setContentType(C.AUDIO_CONTENT_TYPE_MOVIE)
                        .setUsage(C.USAGE_MEDIA)
                        .build(),
                    true
                )
                .setHandleAudioBecomingNoisy(true)
                .build()
            
            setupPlayerListener()
            Log.d("EnhancedPlayerManager", "Player initialized")
        }
    }

    private fun setupPlayerListener() {
        player?.addListener(object : Player.Listener {
            override fun onPlaybackStateChanged(playbackState: Int) {
                _playerState.value = _playerState.value.copy(
                    isBuffering = playbackState == Player.STATE_BUFFERING,
                    hasEnded = playbackState == Player.STATE_ENDED
                )
            }

            override fun onIsPlayingChanged(isPlaying: Boolean) {
                _playerState.value = _playerState.value.copy(isPlaying = isPlaying)
            }

            override fun onPlayWhenReadyChanged(playWhenReady: Boolean, reason: Int) {
                _playerState.value = _playerState.value.copy(isPlaying = playWhenReady)
            }
        })
    }

    fun setStreams(
        videoId: String,
        videoStream: VideoStream?,
        audioStream: AudioStream,
        videoStreams: List<VideoStream>,
        audioStreams: List<AudioStream>,
        subtitles: List<SubtitlesStream>
    ) {
        currentVideoId = videoId
        availableVideoStreams = videoStreams
        availableAudioStreams = audioStreams
        availableSubtitles = subtitles
        
        _playerState.value = _playerState.value.copy(
            currentVideoId = videoId,
            availableQualities = videoStreams.map { 
                QualityOption(
                    height = it.height,
                    label = "${it.height}p",
                    bitrate = it.bitrate.toLong()
                )
            },
            availableAudioTracks = audioStreams.mapIndexed { index, stream ->
                AudioTrackOption(
                    index = index,
                    label = stream.audioTrackName ?: stream.audioTrackId ?: "Track ${index + 1}",
                    language = stream.audioLocale?.displayLanguage ?: "Unknown",
                    bitrate = stream.averageBitrate.toLong()
                )
            },
            availableSubtitles = subtitles.map {
                SubtitleOption(
                    url = it.url ?: "",
                    language = it.languageTag ?: "Unknown",
                    label = it.displayLanguageName ?: it.languageTag ?: "Unknown",
                    isAutoGenerated = it.isAutoGenerated
                )
            },
            currentQuality = videoStream?.height ?: 0,
            currentAudioTrack = 0
        )
        
        loadMedia(videoStream, audioStream)
    }

    @UnstableApi
    private fun loadMedia(videoStream: VideoStream?, audioStream: AudioStream) {
        player?.let { exoPlayer ->
            try {
                val dataSourceFactory = DefaultHttpDataSource.Factory()
                    .setUserAgent("Mozilla/5.0")
                    .setConnectTimeoutMs(10000)
                    .setReadTimeoutMs(10000)
                
                if (videoStream != null && videoStream.url != null) {
                    // Video + Audio mode
                    val videoSource = ProgressiveMediaSource.Factory(dataSourceFactory)
                        .createMediaSource(MediaItem.fromUri(videoStream.url!!))
                    
                    val audioSource = ProgressiveMediaSource.Factory(dataSourceFactory)
                        .createMediaSource(MediaItem.fromUri(audioStream.url ?: ""))
                    
                    val mergedSource = MergingMediaSource(videoSource, audioSource)
                    exoPlayer.setMediaSource(mergedSource)
                } else {
                    // Audio-only mode (for music)
                    val audioSource = ProgressiveMediaSource.Factory(dataSourceFactory)
                        .createMediaSource(MediaItem.fromUri(audioStream.url ?: ""))
                    
                    exoPlayer.setMediaSource(audioSource)
                }
                
                exoPlayer.prepare()
                _playerState.value = _playerState.value.copy(isPrepared = true)
                
                Log.d("EnhancedPlayerManager", "Media loaded successfully")
            } catch (e: Exception) {
                Log.e("EnhancedPlayerManager", "Error loading media", e)
                _playerState.value = _playerState.value.copy(
                    error = "Failed to load media: ${e.message}"
                )
            }
        }
    }

    fun switchQuality(height: Int) {
        val videoStream = availableVideoStreams.find { it.height == height }
        val audioStream = availableAudioStreams.maxByOrNull { it.averageBitrate }
        
        if (videoStream != null && audioStream != null) {
            val currentPosition = player?.currentPosition ?: 0L
            val wasPlaying = player?.isPlaying ?: false
            
            loadMedia(videoStream, audioStream)
            
            player?.seekTo(currentPosition)
            if (wasPlaying) {
                player?.play()
            }
            
            _playerState.value = _playerState.value.copy(currentQuality = height)
        }
    }

    fun switchAudioTrack(index: Int) {
        if (index in availableAudioStreams.indices) {
            val audioStream = availableAudioStreams[index]
            val videoStream = availableVideoStreams.find { it.height == _playerState.value.currentQuality }
            
            val currentPosition = player?.currentPosition ?: 0L
            val wasPlaying = player?.isPlaying ?: false
            
            loadMedia(videoStream, audioStream)
            
            player?.seekTo(currentPosition)
            if (wasPlaying) {
                player?.play()
            }
            
            _playerState.value = _playerState.value.copy(currentAudioTrack = index)
        }
    }

    fun play() {
        player?.play()
    }

    fun pause() {
        player?.pause()
    }

    fun seekTo(position: Long) {
        player?.seekTo(position)
    }

    fun getPlayer(): ExoPlayer? = player

    fun getCurrentPosition(): Long = player?.currentPosition ?: 0L

    fun getDuration(): Long = player?.duration ?: 0L

    fun isPlaying(): Boolean = player?.isPlaying ?: false

    fun stop() {
        player?.stop()
        _playerState.value = _playerState.value.copy(
            isPlaying = false,
            currentVideoId = null
        )
    }

    fun release() {
        player?.release()
        player = null
        trackSelector = null
        _playerState.value = EnhancedPlayerState()
        Log.d("EnhancedPlayerManager", "Player released")
    }
}

data class EnhancedPlayerState(
    val currentVideoId: String? = null,
    val isPlaying: Boolean = false,
    val isBuffering: Boolean = false,
    val isPrepared: Boolean = false,
    val hasEnded: Boolean = false,
    val currentQuality: Int = 0,
    val currentAudioTrack: Int = 0,
    val availableQualities: List<QualityOption> = emptyList(),
    val availableAudioTracks: List<AudioTrackOption> = emptyList(),
    val availableSubtitles: List<SubtitleOption> = emptyList(),
    val error: String? = null
)

data class QualityOption(
    val height: Int,
    val label: String,
    val bitrate: Long
)

data class AudioTrackOption(
    val index: Int,
    val label: String,
    val language: String,
    val bitrate: Long
)

data class SubtitleOption(
    val url: String,
    val language: String,
    val label: String,
    val isAutoGenerated: Boolean
)
